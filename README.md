# â–  Study-Swift - The powerful programming language that is also easy to learn.
SwiftëŠ” Appleì´ iOS, Mac, Apple TV ê·¸ë¦¬ê³  Apple Watch ì•± ê°œë°œìš©ìœ¼ë¡œ ë§Œë“  ê°•ë ¥í•˜ê³  ì§ê´€ì ì¸ í”„ë¡œê·¸ë˜ë° ì–¸ì–´ì…ë‹ˆë‹¤. ê°œë°œìë“¤ì—ê²Œ ì–´ëŠ ë•Œë³´ë‹¤ í° ììœ ë¥¼ ì„ ì‚¬í•˜ê¸° ìœ„í•´ ì„¤ê³„ë˜ì—ˆì£ . SwiftëŠ” ì‚¬ìš©ì´ ê°„í¸í•œ ì˜¤í”ˆ ì†ŒìŠ¤ ì–¸ì–´ë¼ì„œ, ë²ˆëœ©ì´ëŠ” ì•„ì´ë””ì–´ë§Œ ìˆë‹¤ë©´ ëˆ„êµ¬ë‚˜ ë†€ë¼ìš´ ê²°ê³¼ë¬¼ì„ ë§Œë“¤ì–´ë‚¼ ìˆ˜ ìˆë‹µë‹ˆë‹¤.

## â˜… First-Class object - ì¼ê¸‰ ê°ì²´
ìŠ¤ìœ„í”„íŠ¸ëŠ” ê°ì²´ì§€í–¥ ì–¸ì–´ì´ì ë™ì‹œì— í•¨ìˆ˜í˜• ì–¸ì–´ì´ë‹¤. í•¨ìˆ˜í˜• ì–¸ì–´ë¥¼ í•™ìŠµí•˜ê²Œ ë˜ë©´ ë°˜ë“œì‹œ ì¼ê·¹ ê°ì²´ë¼ëŠ” ìš©ì–´ë¥¼ ì ‘í•˜ê²Œ ëœë‹¤. ì»´í“¨í„° í”„ë¡œê·¸ë˜ë° ì–¸ì–´ ë””ìì¸ì—ì„œ, íŠ¹ì • ì–¸ì–´ì˜ ì¼ê¸‰ ê°ì²´ (first-class citizens, ì¼ê¸‰ ê°’, ì¼ê¸‰ ì—”í‹°í‹°, í˜¹ì€ ì¼ê¸‰ ì‹œë¯¼)ì´ë¼ í•¨ì€ ì¼ë°˜ì ìœ¼ë¡œ ë‹¤ë¥¸ ê°ì²´ë“¤ì— ì ìš© ê°€ëŠ¥í•œ ì—°ì‚°ì„ ëª¨ë‘ ì§€ì›í•˜ëŠ” ê°ì²´ë¥¼ ê°€ë¦¬í‚¨ë‹¤. í•¨ìˆ˜ì— ë§¤ê°œë³€ìˆ˜ë¡œ ë„˜ê¸°ê¸°, ë³€ìˆ˜ì— ëŒ€ì…í•˜ê¸°ì™€ ê°™ì€ ì—°ì‚°ë“¤ì´ ì—¬ê¸°ì„œ ë§í•˜ëŠ” ì¼ë°˜ì ì¸ ì—°ì‚°ì˜ ì˜ˆì— í•´ë‹¹í•œë‹¤. ì¼ê¸‰/ì´ê¸‰ ê°ì²´ì˜ ê°œë…ì€ ì˜êµ­ì˜ ì»´í“¨í„° ê³¼í•™ì í¬ë¦¬ìŠ¤í† í¼ ìŠ¤íŠ¸ë ˆì´ì¹˜ì— ì˜í•´ 1960ë…„ëŒ€ì— ì²˜ìŒ ì†Œê°œë˜ì—ˆë‹¤. ê·¸ëŠ” ëª…ì‹œì ìœ¼ë¡œ ì¼ê¸‰ ê°ì²´ì˜ ê°œë…ì„ ì •ì˜í•˜ì§€ëŠ” ì•Šì•˜ìœ¼ë‚˜, Algol í”„ë¡œê·¸ë˜ë° ì–¸ì–´ì˜ ì‹¤ìˆ˜(Real number)ì™€ í”„ë¡œì‹œì €ë¥¼ ë¹„êµí•¨ìœ¼ë¡œì¨ ì¼ê¸‰ ê°ì²´ì˜ ê°œë…ì— ëŒ€í•´ ì²˜ìŒìœ¼ë¡œ ì–¸ê¸‰í•˜ì˜€ë‹¤.

#### âŒ˜ First-Class object Feature
* ê°ì²´ê°€ ëŸ°íƒ€ì„ì—ë„ ìƒì„±ì´ ê°€ëŠ¥í•´ì•¼ í•œë‹¤.
* ì¸ìê°’ìœ¼ë¡œ ê°ì²´ë¥¼ ì „ë‹¬í•  ìˆ˜ ìˆì–´ì•¼ í•œë‹¤. (í•¨ìˆ˜ì˜ ì¸ìê°’ìœ¼ë¡œ í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.)
* ë°˜í™˜ê°’ìœ¼ë¡œ ê°ì²´ë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆì–´ì•¼ í•œë‹¤. (í•¨ìˆ˜ì˜ ë°˜í™˜ íƒ€ì…ìœ¼ë¡œ í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.)
* ë³€ìˆ˜ë‚˜ ë°ì´í„° êµ¬ì¡° ì•ˆì— ì €ì¥í•  ìˆ˜ ìˆì–´ì•¼ í•œë‹¤. (ë³€ìˆ˜ë‚˜ ìƒìˆ˜ì— í•¨ìˆ˜ë¥¼ ëŒ€ì…í•  ìˆ˜ ìˆë‹¤.)
* í• ë‹¹ì— ì‚¬ìš©ëœ ì´ë¦„ê³¼ ê´€ê³„ì—†ì´ ê³ ìœ í•œ êµ¬ë³„ì´ ê°€ëŠ¥í•´ì•¼ í•œë‹¤.

**ì¦‰, í•¨ìˆ˜í˜• ì–¸ì–´ì—ì„œëŠ” í•¨ìˆ˜ê°€ ì¼ê¸‰ ê°ì²´ë¡œ ëŒ€ìš°ë°›ëŠ”ë‹¤.**

## â˜… Difference Struct vs Class
**âŒ˜ êµ¬ì¡°ì²´ì˜ ê°’ ì „ë‹¬ ë°©ì‹: ë³µì‚¬ì— ì˜í•œ ì „ë‹¬**

  êµ¬ì¡°ì²´ëŠ” ì¸ìŠ¤í„´ìŠ¤ë¥¼ ìƒì„±í•œ í›„ ì´ë¥¼ ë³€ìˆ˜ë‚˜ ìƒìˆ˜ì— í• ë‹¹í•˜ê±°ë‚˜ í•¨ìˆ˜ì˜ ì¸ìê°’ìœ¼ë¡œ ì „ë‹¬í•  ë•Œ ê°’ì„ ë³µì‚¬í•˜ì—¬ ì „ë‹¬í•˜ëŠ” ë°©ì‹ì„ ì‚¬ìš©í•œë‹¤. ì´ë¥¼ ê°’ íƒ€ì…(Value Type) or ë³µì‚¬ì— ì˜í•œ ì „ë‹¬ì´ë¼ê³  í•œë‹¤. ìŠ¤ìœ„í”„íŠ¸ì—ì„œ ëª¨ë“  êµ¬ì¡°ì²´ë¥¼ ê°’ íƒ€ì…ì´ë‹¤. ì—´ê±°í˜•(Enum) ì—­ì‹œ ê°’ íƒ€ì…ì´ë‹¤. ë˜í•œ êµ¬ì¡°ì²´ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ë³€ìˆ˜ì— ëŒ€ì…í•˜ë©´ ê¸°ì¡´ì˜ ì¸ìŠ¤í„´ìŠ¤ê°€ ê·¸ëŒ€ë¡œ ëŒ€ì…ë˜ëŠ” ê²ƒì´ ì•„ë‹ˆë¼ ì´ë¥¼ ë³µì‚¬í•œ ìƒˆë¡œìš´ ê°’ì´ ëŒ€ì…ëœë‹¤.
  
  * êµ¬ì¡°ì²´ëŠ” ê°’ì˜ í• ë‹¹ì´ ê³§ ë³µì‚¬ì´ë¯€ë¡œ í•˜ë‚˜ì˜ ì¸ìŠ¤í„´ìŠ¤ëŠ” ì˜¤ë¡œì§€ í•˜ë‚˜ì˜ ë³€ìˆ˜ì™€ ìƒìˆ˜ë§Œì´ ì°¸ì¡°í•  ìˆ˜ ìˆë‹¤.
    
**âŒ˜ í´ë˜ìŠ¤ì˜ ê°’ ì „ë‹¬ ë°©ì‹: ì°¸ì¡°ì— ì˜í•œ ë°©ì‹**

  í´ë˜ìŠ¤ëŠ” ë©”ëª¨ë¦¬ ì£¼ì†Œ ì°¸ì¡°ì— ì˜í•œ ì „ë‹¬ ë°©ì‹ì„ ì‚¬ìš©í•œë‹¤. ì´ë¥¼ ì°¸ì¡° íƒ€ì… (Reference Type)ì´ë¼í•œë‹¤. ì°¸ì¡° íƒ€ì…ì€ ë³€ìˆ˜ë‚˜ ìƒìˆ˜ì— í• ë‹¹ë  ë•Œ, ë˜ëŠ” í•¨ìˆ˜ì˜ ì¸ìê°’ìœ¼ë¡œ ì „ë‹¬ë  ë•Œ ê°’ì˜ ë³µì‚¬ê°€ ì´ë£¨ì–´ì§€ì§€ ì•ŠëŠ”ë‹¤. ëŒ€ì‹ , í˜„ì¬ ì¡´ì¬í•˜ëŠ” ì¸ìŠ¤í„´ìŠ¤ì— ëŒ€í•œ ì°¸ì¡°ê°€ ì „ë‹¬ëœë‹¤. ì°¸ì¡°ë€, ì¸ìŠ¤í„´ìŠ¤ê°€ ì €ì¥ëœ ë©”ëª¨ë¦¬ ì£¼ì†Œ ì •ë³´ê°€ ì „ë‹¬ëœë‹¤ëŠ” ëœ»ì´ë‹¤.
  
  * í´ë˜ìŠ¤ëŠ” ì°¸ì¡° íƒ€ì…ìœ¼ë¡œì„œ í•œ ê³³ì—ì„œ ìˆ˜ì •í•  ê²½ìš° ë‹¤ë¥¸ ê³³ì—ë„ ì ìš©ë˜ëŠ” íŠ¹ì§•ì´ ìˆë‹¤.
  * í•˜ë‚˜ì˜ í´ë˜ìŠ¤ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ì—¬ëŸ¬ ë³€ìˆ˜ë‚˜ ìƒìˆ˜, ë˜ëŠ” í•¨ìˆ˜ì˜ ì¸ìê°’ì—ì„œ ë™ì‹œì— ì°¸ì¡°í•  ìˆ˜ ìˆë‹¤ëŠ” íŠ¹ì§•ì´ ìˆë‹¤.
  * í´ë˜ìŠ¤ ì¸ìŠ¤í„´ìŠ¤ëŠ” ì—¬ëŸ¬ê³³ì—ì„œ ë™ì‹œ ì°¸ì¡°ê°€ ê°€ëŠ¥í•˜ë¯€ë¡œ í•œ ê³³ì—ì„œì˜ ì°¸ì¡°ê°€ ì™„ë£Œë˜ì—ˆë‹¤ê³  í•´ë„ ë§ˆìŒëŒ€ë¡œ ë©”ëª¨ë¦¬ í•´ì œë¥¼ í•  ìˆ˜ ì—†ëŠ” íŠ¹ì§•ì´ ìˆë‹¤. ë‹¤ë¥¸ ê³³ì—ì„œ í•´ë‹¹ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ê³„ì† ì°¸ì¡°í•˜ê³  ìˆê¸° ë•Œë¬¸ì´ë‹¤. ì´ë¥¼ ë°©ì¹˜í•  ê²½ìš° ì˜ëª»ëœ ë©”ëª¨ë¦¬ ì°¸ì¡° ì˜¤ë¥˜ê°€ ë°œìƒí•œë‹¤.

## ğŸ“£ Property - í”„ë¡œí¼í‹°
* í”„ë¡œí¼í‹°ëŠ” í´ë˜ìŠ¤ë‚˜ êµ¬ì¡°ì²´ì— ê°’ì„ ì œê³µí•˜ë©° ì €ì¥ í”„ë¡œí¼í‹°ì™€ ì—°ì‚° í”„ë¡œí¼í‹°ê°€ ì¡´ì¬í•œë‹¤.

* Properties associate values with a particular class, structure, or enumeration. Stored properties store constant and variable values as part of an instance, whereas computed properties calculate (rather than store) a value. Computed properties are provided by classes, structures, and enumerations. Stored properties are provided only by classes and structures.

  Stored and computed properties are usually associated with instances of a particular type. However, properties can also be associated with the type itself. Such properties are known as type properties.

  In addition, you can define property observers to monitor changes in a propertyâ€™s value, which you can respond to with custom actions. Property observers can be added to stored properties you define yourself, and also to properties that a subclass inherits from its superclass.

**âŒ˜ Stored Properties - ì €ì¥ í”„ë¡œí¼í‹°**
* ì…ë ¥ëœ ê°’ì„ ì €ì¥í•˜ê±°ë‚˜ ì €ì¥ëœ ê°’ì„ ì œê³µí•˜ëŠ” ì—­í• ì„ ì œê³µí•œë‹¤.
* ìƒìˆ˜ ë° ë³€ìˆ˜ë¥¼ ì‚¬ìš©í•´ì„œ ì •ì˜ ê¸°ëŠ¥ì„ ì œê³µí•œë‹¤.
* í´ë˜ìŠ¤ì™€ êµ¬ì¡°ì²´ì—ì„œëŠ” ì‚¬ìš©ì´ ê°€ëŠ¥í•˜ì§€ë§Œ, ì—´ê±°í˜•ì—ì„œëŠ” ì‚¬ìš©í•  ìˆ˜ ì—†ë‹¤.

**âŒ˜ Lazy Stored Properties - ì§€ì—° ì €ì¥ í”„ë¡œí¼í‹°**
* A lazy stored property is a property whose initial value is not calculated until the first time it is used. You indicate a lazy stored property by writing the lazy modifier before its declaration.
  
  Lazy properties are useful when the initial value for a property is dependent on outside factors whose values are not known until after an instanceâ€™s initialization is complete. Lazy properties are also useful when the initial value for a property requires complex or computationally expensive setup that should not be performed unless or until it is needed.

* í´ë˜ìŠ¤ ì¸ìŠ¤í„´ìŠ¤ê°€ ìƒì„±ë˜ì–´ ëª¨ë“  ì €ì¥ í”„ë¡œí¼í‹°ê°€ ë§Œë“¤ì–´ì§€ë”ë¼ë„ lazy í‚¤ì›Œë“œê°€ ë¶™ì€ í”„ë¡œí¼í‹°ëŠ” ì„ ì–¸ë§Œ ë  ë¿ ì´ˆê¸°í™”ë˜ì§€ ì•Šê³  ê³„ì† ëŒ€ê¸°í•˜ê³  ì‡ë‹¤ê°€ í”„ë¡œí¼í‹°ê°€ í˜¸ì¶œë˜ëŠ” ìˆœê°„ì— ì´ˆê¸°í™” ëœë‹¤. ì´ì²˜ëŸ¼ í˜¸ì¶œë˜ê¸° ì „ì—ëŠ” ì„ ì–¸ë§Œ ëœ ìƒíƒœë¡œ ëŒ€ê¸°í•˜ë‹¤ê°€ ì‹¤ì œë¡œ í˜¸ì¶œë˜ëŠ” ì‹œì ì—ì„œ ì´ˆê¸°í™”ê°€ ì´ë£¨ì–´ì§€ëŠ” ì €ì¥ í”„ë¡œí¼í‹°ë¥¼ ì§€ì—° ì €ì¥ í”„ë¡œí¼í‹°ë¼ í•œë‹¤.

```swift
class DataImporter {
    /*
    DataImporter is a class to import data from an external file.
    The class is assumed to take a nontrivial amount of time to initialize.
    */
    var filename = "data.txt"
    // the DataImporter class would provide data importing functionality here
}

class DataManager {
    lazy var importer = DataImporter()
    var data = [String]()
    // the DataManager class would provide data management functionality here
}

let manager = DataManager()
manager.data.append("Some data")
manager.data.append("Some more data")
// the DataImporter instance for the importer property has not yet been created

print(manager.importer.filename)
// the DataImporter instance for the importer property has now been created
// Prints "data.txt"
```

* * *

**âŒ˜ Computed Properties - ì—°ì‚° í”„ë¡œí¼í‹°**
* íŠ¹ì • ì—°ì‚°ì„ í†µí•´ ê°’ì„ ë§Œë“¤ì–´ ì œê³µí•˜ëŠ” ì—­í• ì„ ì œê³µí•œë‹¤.
* ë³€ìˆ˜ë§Œ ì‚¬ìš©í•´ì„œ ì •ì˜ ê¸°ëŠ¥ì„ ì œê³µí•œë‹¤.
* í´ë˜ìŠ¤, êµ¬ì¡°ì²´, ì—´ê±°í˜• ëª¨ë‘ì—ì„œ ì‚¬ìš© ê°€ëŠ¥í•˜ë‹¤.

```swift
struct Point {
    var x = 0.0, y = 0.0
}
struct Size {
    var width = 0.0, height = 0.0
}
struct Rect {
    var origin = Point()
    var size = Size()
    var center: Point {
        get {
            let centerX = origin.x + (size.width / 2)
            let centerY = origin.y + (size.height / 2)
            return Point(x: centerX, y: centerY)
        }
        set(newCenter) {
            origin.x = newCenter.x - (size.width / 2)
            origin.y = newCenter.y - (size.height / 2)
        }
    }
}
var square = Rect(origin: Point(x: 0.0, y: 0.0),
                  size: Size(width: 10.0, height: 10.0))
let initialSquareCenter = square.center
square.center = Point(x: 15.0, y: 15.0)
print("square.origin is now at (\(square.origin.x), \(square.origin.y))")
// Prints "square.origin is now at (10.0, 10.0)"
```

**âŒ˜ Read-Only Computed Properties - ì½ê¸° ì „ìš© ì—°ì‚° í”„ë¡œí¼í‹°**
* A computed property with a getter but no setter is known as a read-only computed property. A read-only computed property always returns a value, and can be accessed through dot syntax, but cannot be set to a different value.
  
  You must declare computed propertiesâ€”including read-only computed propertiesâ€”as variable properties with the var keyword, because their value is not fixed. The let keyword is only used for constant properties, to indicate that their values cannot be changed once they are set as part of instance initialization.

```swift
struct Cuboid {
    var width = 0.0, height = 0.0, depth = 0.0
    var volume: Double {
        return width * height * depth
    }
}
let fourByFiveByTwo = Cuboid(width: 4.0, height: 5.0, depth: 2.0)
print("the volume of fourByFiveByTwo is \(fourByFiveByTwo.volume)")
// Prints "the volume of fourByFiveByTwo is 40.0"
```

> This example defines a new structure called Cuboid, which represents a 3D rectangular box with width, height, and depth properties. This structure also has a read-only computed property called volume, which calculates and returns the current volume of the cuboid. It doesnâ€™t make sense for volume to be settable, because it would be ambiguous as to which values of width, height, and depth should be used for a particular volume value. Nonetheless, it is useful for a Cuboid to provide a read-only computed property to enable external users to discover its current calculated volume.

## â˜… Property Observers - í”„í† í¼í‹° ì˜µì €ë²„
* í”„ë¡œí¼í‹° ì˜µì €ë²„ëŠ” í”„ë¡œí¼í‹°ì˜ ê°’ì„ ì§ì ‘ ë³€ê²½í•˜ê±°ë‚˜ ì‹œìŠ¤í…œì— ì˜í•´ ìë™ìœ¼ë¡œ ë³€ê²½í•˜ëŠ” ê²½ìš°ì— ìƒê´€ì—†ì´ ì¼ë‹¨ í”„ë¡œí¼í‹°ì˜ ê°’ì´ ì„¤ì •ë˜ë©´ í˜¸ì¶œëœë‹¤. ì‹¬ì§€ì–´ í”„ë¡œí¼í‹°ì— í˜„ì¬ì™€ ë™ì¼í•œ ê°’ì´ ì¬í• ë‹¹ì´ ë˜ì–´ë„ í˜¸ì¶œëœë‹¤. ì˜ˆë¥¼ ë“¤ì–´ ì €ì¥ í”„ë¡œí¼í‹°ì— ê°’ì„ ëŒ€ì…í•˜ëŠ” êµ¬ë¬¸ì´ ìˆ˜í–‰ë˜ê±°ë‚˜ ì—°ì‚° í”„ë¡œí¼í‹°ì—ì„œ set êµ¬ë¬¸ì´ ì‹¤í–‰ë˜ëŠ” ëª¨ë“  ê²½ìš°ì— í”„ë¡œí¼í‹° ì˜µì €ë²„ê°€ í˜¸ì¶œëœë‹¤.

* í”„ë¡œí¼í‹° ì˜µì €ë²„ì—ëŠ” willSetì™€ didSetì´ ì¡´ì¬í•œë‹¤. willSetì€ í”„ë¡œí¼í‹°ì˜ ê°’ì´ ë³€ê²½ë˜ê¸° ì§ì „ì— í˜¸ì¶œë˜ëŠ” ì˜µì €ë²„ì´ê³  didSetì€ í”„ë¡œí¼í‹°ì˜ ê°’ì´ ë³€ê²½ëœ ì§í›„ì— í˜¸ì¶œë˜ëŠ” ì˜µì €ë²„ì´ë‹¤.

* The willSet and didSet observers of superclass properties are called when a property is set in a subclass initializer, after the superclass initializer has been called. They are not called while a class is setting its own properties, before the superclass initializer has been called.

```swift
class StepCounter {
    var totalSteps: Int = 0 {
        willSet(newTotalSteps) {
            print("About to set totalSteps to \(newTotalSteps)")
        }
        didSet {
            if totalSteps > oldValue  {
                print("Added \(totalSteps - oldValue) steps")
            }
        }
    }
}
let stepCounter = StepCounter()
stepCounter.totalSteps = 200
// About to set totalSteps to 200
// Added 200 steps
stepCounter.totalSteps = 360
// About to set totalSteps to 360
// Added 160 steps
stepCounter.totalSteps = 896
// About to set totalSteps to 896
// Added 536 steps
```

## â˜… Type Property - íƒ€ì… í”„ë¡œí¼í‹°
* ì¸ìŠ¤í„´ìŠ¤ë¥¼ ìƒì„±í•˜ì§€ ì•Šê³  í´ë˜ìŠ¤ë‚˜ êµ¬ì¡°ì²´ ìì²´ì— ê°’ì„ ì €ì¥í•˜ê²Œ ë˜ë©° ì´ë¥¼ íƒ€ì… í”„ë¡œí¼í‹°(Type Property)ë¼ê³  í•œë‹¤.

* íƒ€ì… í”„ë¡œí¼í‹°(Type Property)ì€ í´ë˜ìŠ¤ë‚˜ êµ¬ì¡°ì²´ì˜ ì¸ìŠ¤í„´ìŠ¤ì— ì†í•˜ëŠ” ê°’ì´ ì•„ë‹ˆë¼ í´ë˜ìŠ¤ë‚˜ êµ¬ì¡°ì²´ ìì²´ì— ì†í•˜ëŠ” ê°’ì´ë¯€ë¡œ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ìƒì„±í•˜ì§€ ì•Šê³  í´ë˜ìŠ¤ë‚˜ êµ¬ì¡°ì²´ ìì²´ì— ì €ì¥í•˜ê²Œ ë˜ë©°, ì €ì¥ëœ ê°’ì€ ëª¨ë“  ì¸ìŠ¤í„´ìŠ¤ê°€ ê³µí†µìœ¼ë¡œ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.

* ì¸ìŠ¤í„´ìŠ¤ í”„ë¡œí¼í‹°ëŠ” ê°œë³„ ì¸ìŠ¤í„´ìŠ¤ë§ˆë‹¤ ë‹¤ë¥¸ ê°’ì„ ì €ì¥í•  ìˆ˜ ìˆì–´ì„œ í•˜ë‚˜ì˜ ì¸ìŠ¤í„´ìŠ¤ì—ì„œ ë³€ê²½í•œ í”„ë¡œí¼í‹°ì˜ ê°’ì€ ê·¸ ì¸ìŠ¤í„´ìŠ¤ ë‚´ì—ì„œë§Œ ìœ ì§€ë  ë¿ ë‚˜ë¨¸ì§€ ì¸ìŠ¤í„´ìŠ¤ì— ì˜í–¥ì„ ë¯¸ì¹˜ì§€ ì•Šì§€ë§Œ, íƒ€ì… í”„ë¡œí¼í‹°ëŠ” ì¸ìŠ¤í„´ìŠ¤ê°€ ì•„ë¬´ë¦¬ ë§ë”ë¼ë„ ëª¨ë“  ì¸ìŠ¤í„´ìŠ¤ê°€ í•˜ë‚˜ì˜ ê°’ì„ ê³µìš©ìœ¼ë¡œ ì‚¬ìš©í•œë‹¤. ë˜í•œ ìŠ¤ìœ„í”„íŠ¸ì—ì„œ íƒ€ì… í”„ë¡œí¼í‹°ëŠ” í´ë˜ìŠ¤ë‚˜ êµ¬ì¡°ì²´, ì—´ê±°í˜• ê°ì²´ ë‚´ì— ì„ ì–¸í•˜ëŠ” ê²ƒì´ë¯€ë¡œ ì„ ì–¸ëœ ê°ì²´ ë‚´ì—ì„œë§Œ ì ‘ê·¼ ê°€ëŠ¥í•œ ë²”ìœ„ë¥¼ ê°€ì§„ë‹¤.

```swift
struct SomeStructure {
    static var storedTypeProperty = "Some value."
    static var computedTypeProperty: Int {
        return 1
    }
}
enum SomeEnumeration {
    static var storedTypeProperty = "Some value."
    static var computedTypeProperty: Int {
        return 6
    }
}
class SomeClass {
    static var storedTypeProperty = "Some value."
    static var computedTypeProperty: Int {
        return 27
    }
    class var overrideableComputedTypeProperty: Int {
        return 107
    }
}
```

## â˜… ARC (Auto Reference Counting)

* iOSëŠ” ë ˆí¼ëŸ°ìŠ¤ ì¹´ìš´íŒ…ì„ í†µí•´ ë ˆí¼ëŸ°ìŠ¤ê°€ ë” ì´ìƒ ì‚¬ìš©ë˜ì§€ ì•ŠëŠ” ì‹œì ì„ ê²°ì •í•˜ì—¬ ë ˆí¼ëŸ°ìŠ¤ê°€ í• ë‹¹ë°›ì•„ ì‚¬ìš©í•˜ë˜ ë©”ëª¨ë¦¬ë¥¼ í•´ì œí•  ìˆ˜ ìˆë„ë¡ ë§Œë“­ë‹ˆë‹¤. ê°œë…ì ìœ¼ë¡œ ê°„ë‹¨í•œ ê²ƒìœ¼ë¡œ í”„ë¡œí¼í‹°, ìƒìˆ˜, ë³€ìˆ˜ì— ë ˆí¼ëŸ°ìŠ¤ê°€ ì§€ì •ë˜ë©´ ë•Œ ì—¬ê¸°ì— ë“¤ì–´ìˆëŠ” ì¹´ìš´íŠ¸ë¥¼ ì¦ê°€ì‹œí‚¤ê³  í”„ë¡œí¼í‹°, ìƒìˆ˜, ë³€ìˆ˜ê°€ í•´ì œë˜ë©´ ì¹´ìš´íŠ¸ë¥¼ ê°ì†Œì‹œí‚µë‹ˆë‹¤. ë³´ìœ í•œ ì¹´ìš´íŠ¸ê°€ 0ì´ ë˜ë©´ ë©”ëª¨ë¦¬ë¥¼ í•´ì œì‹œí‚µë‹ˆë‹¤.

* ì¸ìŠ¤í„´ìŠ¤ë¥¼ ëª¨ë‹ˆí„°ë§í•˜ë©´ì„œ ë³€ìˆ˜ë‚˜ ìƒìˆ˜, í•¨ìˆ˜ì˜ ì¸ìê°’ìœ¼ë¡œ í• ë‹¹ë˜ë©´ ì¹´ìš´íŠ¸ë¥¼ 1ì¦ê°€ì‹œí‚¤ê³  í•´ë‹¹ ë³€ìˆ˜ë‚˜ ìƒìˆ˜ë“¤ì´ ì¢…ë£Œë˜ë©´ ì¹´ìš´íŠ¸ë¥¼ 1 ê°ì†Œì‹œí‚¤ëŠ” ì‘ì—…ì„ ê³„ì†í•˜ë©´ì„œ ì¸ìŠ¤í„´ìŠ¤ì˜ ì°¸ì¡° ìˆ˜ë¥¼ ê³„ì‚°í•œë‹¤. ì´ ê³¼ì •ì—ì„œ ì¸ìŠ¤í„´ìŠ¤ì˜ ì°¸ì¡° ì¹´ìš´íŠ¸ê°€ 0ì´ ë˜ë©´ ë©”ëª¨ë¦¬ í•´ì œ ëŒ€ìƒìœ¼ë¡œ ê°„ì£¼í•˜ì—¬ ì ì ˆíˆ ë©”ëª¨ë¦¬ì—ì„œ í•´ì œí•œë‹¤.

<p align="center">
  
<img src="https://user-images.githubusercontent.com/20036523/44619524-df672200-a8c2-11e8-8ecd-fab5225754d3.png" >

</p>

## :mega: ê³ ì°¨ í•¨ìˆ˜ (é«˜æ¬¡å‡½æ•¸, Higher-order function)

* ê³ ì°¨ í•¨ìˆ˜(é«˜æ¬¡å‡½æ•¸, higher-order function)ëŠ” ìˆ˜í•™ê³¼ ì»´í“¨í„° ê³¼í•™ì—ì„œ ì ì–´ë„ ë‹¤ìŒ ì¤‘ í•˜ë‚˜ë¥¼ ìˆ˜í–‰í•˜ëŠ” í•¨ìˆ˜ì´ë‹¤.

1. í•˜ë‚˜ ì´ìƒì˜ í•¨ìˆ˜ë¥¼ ì¸ìˆ˜ë¡œ ì·¨í•œë‹¤. (ì˜ˆ: ì ˆì°¨ì  ë§¤ê°œë³€ìˆ˜)

2. í•¨ìˆ˜ë¥¼ ê²°ê³¼ë¡œ ë°˜í™˜í•œë‹¤.

* Swiftì—ì„œì˜ ê³ ì°¨í•¨ìˆ˜ëŠ” MAP, CompactMAP, Filter, Reduce ë“±ì´ ìˆë‹¤.

## :mega: í´ë¡œì € (Closure)

* ì»´í“¨í„° ì–¸ì–´ì—ì„œ í´ë¡œì €(Closure)ëŠ” ì¼ê¸‰ ê°ì²´ í•¨ìˆ˜(first-class functions)ì˜ ê°œë…ì„ ì´ìš©í•˜ì—¬ ìŠ¤ì½”í”„(scope)ì— ë¬¶ì¸ ë³€ìˆ˜ë¥¼ ë°”ì¸ë”© í•˜ê¸° ìœ„í•œ ì¼ì¢…ì˜ ê¸°ìˆ ì´ë‹¤. ê¸°ëŠ¥ìƒìœ¼ë¡œ, í´ë¡œì €ëŠ” í•¨ìˆ˜ë¥¼ ì €ì¥í•œ ë ˆì½”ë“œ(record)ì´ë©°, ìŠ¤ì½”í”„(scope)ì˜ ì¸ìˆ˜(Factor)ë“¤ì€ í´ë¡œì €ê°€ ë§Œë“¤ì–´ì§ˆ ë•Œ ì •ì˜(define)ë˜ë©°, ìŠ¤ì½”í”„ ë‚´ì˜ ì˜ì—­ì´ ì†Œë©¸(remove)ë˜ì—ˆì–´ë„ ê·¸ì— ëŒ€í•œ ì ‘ê·¼(access)ì€ ë…ë¦½ëœ ë³µì‚¬ë³¸ì¸ í´ë¡œì €ë¥¼ í†µí•´ ì´ë£¨ì–´ì§ˆ ìˆ˜ ìˆë‹¤.

```swift
{ (ë§¤ê°œ ë³€ìˆ˜ë“¤) -> ë°˜í™˜ íƒ€ì… in
   ì‹¤í–‰ ì½”ë“œ
}
```

* í´ë¡œì €ë€ ì½”ë“œì˜ ë¸”ëŸ­ì´ì, ì¼ê¸‰ ê°ì²´ë¡œ ì™„ë²½í•œ ì—­í• ì„ ìˆ˜í–‰í•œë‹¤. ì¼ê¸‰ ê°ì²´ë€ ì „ë‹¬ ì¸ìë¡œ ë³´ë‚¼ ìˆ˜ ìˆê³ , ë³€ìˆ˜/ìƒìˆ˜ ë“±ìœ¼ë¡œ ì €ì¥í•˜ê±°ë‚˜ ì „ë‹¬í•  ìˆ˜ ìˆìœ¼ë©°, í•¨ìˆ˜ì˜ ë°˜í™˜ ê°’ì´ ë  ìˆ˜ë„ ìˆë‹¤.

```swift
let action = UIAlertAction(title: String?, style: UIAlertActionStyle, handler ((UIAlertAction) -> Void)?)

let action = UIAlertAction(title: "OK", style: .default) {
  (UIAlertAction) in
  // code
}

let action = UIAlertAction(title: "OK", style: .default) {
  (action) in
}

```

## â˜… Etc
* ì˜µì…”ë„ (Optinal)ì€ í”„ë¡œê·¸ë¨ì˜ ì•ˆì •ì„±ì„ ë†’ì´ê¸° ìœ„í•œ ê°œë…ìœ¼ë¡œì„œ nilì„ ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” íƒ€ì…ê³¼ ì‚¬ìš©í•  ìˆ˜ ì—†ëŠ” íƒ€ì…ìœ¼ë¡œ êµ¬ë¶„í•˜ê³  ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” íƒ€ì…ì„ ê°€ë¦¬ì¼œ ì˜µì…”ë„ íƒ€ì… (Optional Type)ì´ë¼ê³  í•œë‹¤.

* * *

**âŒ˜ ì—… ìºìŠ¤íŒ… (Up Casting)**
1. í•˜ìœ„ í´ë˜ìŠ¤ íƒ€ì…ì„ ìƒìœ„ í´ë˜ìŠ¤ íƒ€ì…ìœ¼ë¡œ ë³€í™˜í•  ë•Œ
2. ìºìŠ¤íŒ…í•˜ê¸° ì „ íƒ€ì…ì´ í•˜ìœ„ í´ë˜ìŠ¤, ìºìŠ¤íŒ…í•œ í›„ íƒ€ì…ì´ ìƒìœ„ í´ë˜ìŠ¤ì¼ ë•Œ
3. ìºìŠ¤íŒ…í•œ ê²°ê³¼, ìºìŠ¤íŒ…í•˜ê¸° ì „ íƒ€ì…ë³´ë‹¤ ì¶”ìƒí™”ë  ë•Œ
4. ì¼ë°˜ì ìœ¼ë¡œ ìºìŠ¤íŒ… ê³¼ì •ì—ì„œ ì˜¤ë¥˜ê°€ ë°œìƒí•  ê°€ëŠ¥ì„±ì´ ì—†ë‹¤.

* * *

**âŒ˜ ë‹¤ìš´ ìºìŠ¤íŒ… (Down Casting)**
1. ìƒìœ„ í´ë˜ìŠ¤ íƒ€ì…ì„ í•˜ìœ„ í´ë˜ìŠ¤ íƒ€ì…ìœ¼ë¡œ ìºìŠ¤íŒ…í•  ë•Œ
2. ìºìŠ¤íŒ…í•˜ê¸° ì „ íƒ€ì…ì´ ìƒìœ„ í´ë˜ìŠ¤, ìºìŠ¤íŒ…í•œ í›„ íƒ€ì…ì´ í•˜ìœ„ í´ë˜ìŠ¤
3. ìºìŠ¤íŒ…í•œ ê²°ê³¼, ìºìŠ¤íŒ…í•˜ê¸° ì „ íƒ€ì…ë³´ë‹¤ êµ¬ì²´í™”ë  ë•Œ
4. ìºìŠ¤íŒ… ê³¼ì •ì—ì„œ ì˜¤ë¥˜ê°€ ë°œìƒí•  ê°€ëŠ¥ì„±ì´ ìˆë‹¤.
5. ì˜¤ë¥˜ì— ëŒ€í•œ ì²˜ë¦¬ ë°©ì‹ì— ë”°ë¼ ì˜µì…”ë„ ìºìŠ¤íŒ…ê³¼ ê°•ì œ ìºìŠ¤íŒ…ìœ¼ë¡œ ë‚˜ë‰œë‹¤.

## â˜… Access Control - ì ‘ê·¼ì œì–´ ì§€ì‹œì

* `Open` access and public access enable entities to be used within any source file from their defining module, and also in a source file from another module that imports the defining module. You typically use open or public access when specifying the public interface to a framework. The difference between open and public access is described below.

* `Internal` access enables entities to be used within any source file from their defining module, but not in any source file outside of that module. You typically use internal access when defining an appâ€™s or a frameworkâ€™s internal structure.

* `File-private` access restricts the use of an entity to its own defining source file. Use file-private access to hide the implementation details of a specific piece of functionality when those details are used within an entire file.

* `Private` access restricts the use of an entity to the enclosing declaration, and to extensions of that declaration that are in the same file. Use private access to hide the implementation details of a specific piece of functionality when those details are used only within a single declaration.

## â˜… Delegate - ë¸ë¦¬ê²Œì´íŠ¸

|Delegates Image 001|Delegates Image 002|
|:-----------------:|:-----------------:|
|![](https://developer.apple.com/library/archive/documentation/General/Conceptual/CocoaEncyclopedia/Art/delegation1.jpg)|![](https://developer.apple.com/library/archive/documentation/General/Conceptual/CocoaEncyclopedia/Art/delegation2.jpg)|

* A delegate is an object that acts on behalf of, or in coordination with, another object when that object encounters an event in a program. The delegating object is often a responder objectâ€”that is, an object inheriting from NSResponder in AppKit or UIResponder in UIKitâ€”that is responding to a user event. The delegate is an object that is delegated control of the user interface for that event, or is at least asked to interpret the event in an application-specific manner. </br></br>To better appreciate the value of delegation, it helps to consider an off-the-shelf Cocoa object such as a text field (an instance of NSTextField or UITextField) or a table view (an instance of NSTableView or UITableView ). These objects are designed to fulfill a specific role in a generic fashion; a window object in the AppKit framework, for example, responds to mouse manipulations of its controls and handles such things as closing, resizing, and moving the physical window. This restricted and generic behavior necessarily limits what the object can know about how an event affects (or will affect) something elsewhere in the application, especially when the affected behavior is specific to your application. Delegation provides a way for your custom object to communicate application-specific behavior to the off-the-shelf object. </br></br>The programming mechanism of delegation gives objects a chance to coordinate their appearance and state with changes occurring elsewhere in a program, changes usually brought about by user actions. More importantly, delegation makes it possible for one object to alter the behavior of another object without the need to inherit from it. The delegate is almost always one of your custom objects, and by definition it incorporates application-specific logic that the generic and delegating object cannot possibly know itself.

## â˜… DataSource

* **A data source is like a delegate except that, instead of being delegated control of the user interface, it is delegated control of data.** A data source is an outlet held by NSView and UIView objects such as table views and outline views that require a source from which to populate their rows of visible data. The data source for a view is usually the same object that acts as its delegate, but it can be any object. As with the delegate, the data source must implement one or more methods of an informal protocol to supply the view with the data it needs and, in more advanced implementations, to handle data that users directly edit in such views. </br><br/> As with delegates, data sources are objects that must be present to receive messages from the objects requesting data. The application that uses them must ensure their persistence, retaining them if necessary in memory-managed code. </br><br/> Data sources are responsible for the persistence of the objects they hand out to user-interface objects. In other words, they are responsible for the memory management of those objects. However, whenever a view object such as an outline view or table view accesses the data from a data source, it retains the objects as long as it uses the data. But it does not use the data for very long. Typically it holds on to the data only long enough to display it.



## â˜… [Difference Between Value Type and Reference Type in Swift](https://medium.com/@abhimuralidharan/difference-between-value-type-and-a-reference-type-in-ios-swift-18cb5145ad7a)

<p align="center">
  <img src="https://cdn-images-1.medium.com/max/1600/1*oiSNPErZHJ40FcWNTxAM0A.gif" />
</p>

* Types in Swift fall into one of two categories: first, â€œvalue typesâ€, where each instance keeps a unique copy of its data, usually defined as a struct, enum, or tuple. The second, â€œreference typesâ€, where instances share a single copy of the data, and the type is usually defined as a class.

###### â—† Value type
```swift
// Value type example
struct S { var data: Int = -1 }
var a = S()
var b = a						// a is copied to b
a.data = 42						// Changes a, not b
println("\(a.data), \(b.data)")	// prints "42, -1"
```

###### â—† Reference type
```swift
// Reference type example
class C { var data: Int = -1 }
var x = C()
var y = x						// x is copied to y
x.data = 42						// changes the instance referred to by x (and y)
println("\(x.data), \(y.data)")	// prints "42, 42"
```

* **Value Type**â€Š-â€Šeach instance keeps a unique copy of its data. A type that creates a new instance (copy) when assigned to a variable or constant, or when passed to a function. **(Get Stored on Stack Memory)**


* **Reference Type**â€Š-â€Šeach instances share a single copy of the data. A type that once initialized, when assigned to a variable or constant, or when passed to a function, returns a reference to the same existing instance. **(Get Stored on Managed Heap Memory)**


|Value Type|Reference Type|
|:--------:|:------------:|
|structures (including booleans, characters, integer numbers, floating-point numbers, fixed-point numbers, immutable strings, tuples, lists, dictionaries, sets, stacks, queues), enumerations (including optionals)|functions, classes, interfaces|

* **In Swift, Array, String, and Dictionary are all value types.** They behave much like a simple int value in C, acting as a unique instance of that data. You donâ€™t need to do anything special â€” such as making an explicit copy â€” to prevent other code from modifying that data behind your back. Importantly, you can safely pass copies of values across threads without synchronization. In the spirit of improving safety, this model will help you write more predictable code in Swift.

* As mentioned earlier, reference type instances are stored in heap and instances of a value type such as struct resides in a region of memory called stack. **If the value type instance is part of a class instance, the value is stored in the heap along with the class instance.**

###### â€» Use a value type when:

* Comparing instance data with == makes sense
* You want copies to have independent state
* The data will be used in code across multiple threads

###### â€» Use a reference type (e.g. use a class) when:

* Comparing instance identity with === makes sense
* You want to create shared, mutable state

## â˜… REFERENCE

:airplane: [Swift REFERENCE URL](https://github.com/ChangYeop-Yang/Study-Swift/issues/2)

## â˜… Developer Information

|:rocket: Github QR Code|:pencil: Naver-Blog QR Code|:eyeglasses: Linked-In QR Code|
|:---------------------:|:-------------------------:|:----------------------------:|
|![](https://user-images.githubusercontent.com/20036523/50044128-60406880-00c2-11e9-8d57-ea1cb8e6b2a7.jpg)|![](https://user-images.githubusercontent.com/20036523/50044131-60d8ff00-00c2-11e9-818c-cf5ad97dc76e.jpg)|![](https://user-images.githubusercontent.com/20036523/50044130-60d8ff00-00c2-11e9-991a-107bffa2bf57.jpg)|
